input {
  http_poller {
    urls => {
      indicia => {
        method => get
        url => "http://devwarehouse.indicia.org.uk/index.php/services/rest/reports/library/occurrences/list_for_elastic.xml"
        headers => {
          Accept => "application/json"
          Authorization => "USER:BRC:SECRET:1FM8Gu6j7"
        }
        query => {
          proj_id => "BRC5"
          from_update_date => "1900-01-01"
          autofeed => 't'
        }
      }
    }
    request_timeout => 120
    schedule => { cron => "* * * * * UTC"}
    codec => "json"
  }
}
filter {
  # Lookup taxon information from our CSV File and store in the
  # taxon_data_csv field. Translation can only read one field from the
  # CSV so we store all the data in a single field separated by ~.
  translate {
    dictionary_path => "/Users/john/Documents/Git repos/indicia_support_files/Elasticsearch/data/taxa.csv"
    field => "taxon_key"
    destination => "taxon_data_csv"
  }
  # Split all the taxon data csv field content into separate fields.
  csv {
    source => "taxon_data_csv"
    separator => "~"
    skip_empty_columns => true
    columns => [
      "accepted_taxon_key",
      "taxon_name",
      "authority",
      "taxon_group",
      "common_name",
      "taxon_rank",
      "taxon_rank_sort_order",
      "marine_flag",
      "taxon_kingdom",
      "taxon_kingdom_key",
      "taxon_phylum",
      "taxon_phylum_key",
      "taxon_class",
      "taxon_class_key",
      "taxon_order",
      "taxon_order_key",
      "taxon_family",
      "taxon_family_key",
      "taxon_subfamily",
      "taxon_subfamily_key",
      "taxon_genus",
      "taxon_genus_key"
    ]
    remove_field => "taxon_data_csv"
  }
  translate {
    dictionary_path => "/Users/john/Documents/Git repos/indicia_support_files/Elasticsearch/data/taxon-paths.csv"
    field => "taxon_key"
    destination => "taxon_path_keys"
  }
  mutate {
    #convert => {
    #  "geom" => "geo_shape"
    #  "point" => "geo_point"
    #}
    split => {
      "taxon_path_keys" => ","
    }
  }
  mutate {
    rename => {
      "point_x" => "point[lon]"
      "point_y" => "point[lat]"
      "taxon_key" => "taxon[key]"
      "accepted_taxon_key" => "[taxon][accepted_key]"
      "taxon_name" => "[taxon][name]"
      "authority" => "[taxon][authority]"
      "taxon_group" => "[taxon][group]"
      "common_name" => "[taxon][common_name]"
      "taxon_rank" => "[taxon][rank]"
      "taxon_rank_sort_order" => "[taxon][rank_sort_order]"
      "marine_flag" => "[taxon][marine]"
      "taxon_kingdom" => "[taxon][kingdom][name]"
      "taxon_kingdom_key" => "[taxon][kingdom][key]"
      "taxon_phylum" => "[taxon][phylum][name]"
      "taxon_phylum_key" => "[taxon][phylum][key]"
      "taxon_class" => "[taxon][class][name]"
      "taxon_class_key" => "[taxon][class][key]"
      "taxon_order" => "[taxon][order][name]"
      "taxon_order_key" => "[taxon][order][key]"
      "taxon_family" => "[taxon][family][name]"
      "taxon_family_key" => "[taxon][family][key]"
      "taxon_subfamily" => "[taxon][subfamily][name]"
      "taxon_subfamily_key" => "[taxon][subfamily][key]"
      "taxon_genus" => "[taxon][genus][name]"
      "taxon_genus_key" => "[taxon][genus][key]"
      "taxon_path_keys" => "[taxon][path_keys]"
      "comment" => "[comments][record_comment]"
      "sample_comment" => "[comments][sample_comment]"
      "attr_sex" => "[record_attributes][sex]"
      "attr_stage" => "[record_attributes][stage]"
      "attr_sex_stage" => "[record_attributes][sex_stage]"
      "attr_sex_stage_count" => "[record_attributes][sex_stage_count]"
      "attr_certainty" => "[record_attributes][recorder_certainty]"
      "attr_det_name" => "[record_attributes][determiner_name]"
      "attr_biotope" => "[sample_attributes][biotope]"
      "attr_sample_method" => "[sample_attributes][method]"
    }
  }
  ruby {
    # Script to clean up nulls and empty values.
    path => "/Users/john/Documents/Git repos/indicia_support_files/Elasticsearch/logstash-rb/compact_event.rb"
  }
}
output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "occurrence"
    # Our records need a unique ID in the index for updates.
    document_id => "warehouse1|%{id}"
  }
  # Uncomment the following to see the data output to the terminal.
  # stdout { codec => json }
}